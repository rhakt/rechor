// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCENE_RECHOR_MODEL_H_
#define FLATBUFFERS_GENERATED_SCENE_RECHOR_MODEL_H_

#include <flatbuffers/flatbuffers.h>


namespace rechor {
namespace model {

struct Frame;
struct AnimFrame;
struct Anim;
struct Mesh;
struct Scene;

struct Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4,
  };
  const flatbuffers::Vector<float> *data() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct FrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) { fbb_.AddOffset(Frame::VT_DATA, data); }
  FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FrameBuilder &operator=(const FrameBuilder &);
  flatbuffers::Offset<Frame> Finish() {
    auto o = flatbuffers::Offset<Frame>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Frame> CreateFrame(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  FrameBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct AnimFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESHMATRICES = 4,
    VT_BONEMATRICES = 6,
  };
  const flatbuffers::Vector<flatbuffers::Offset<Frame>> *meshMatrices() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Frame>> *>(VT_MESHMATRICES); }
  const flatbuffers::Vector<flatbuffers::Offset<Frame>> *boneMatrices() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Frame>> *>(VT_BONEMATRICES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESHMATRICES) &&
           verifier.Verify(meshMatrices()) &&
           verifier.VerifyVectorOfTables(meshMatrices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BONEMATRICES) &&
           verifier.Verify(boneMatrices()) &&
           verifier.VerifyVectorOfTables(boneMatrices()) &&
           verifier.EndTable();
  }
};

struct AnimFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshMatrices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> meshMatrices) { fbb_.AddOffset(AnimFrame::VT_MESHMATRICES, meshMatrices); }
  void add_boneMatrices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> boneMatrices) { fbb_.AddOffset(AnimFrame::VT_BONEMATRICES, boneMatrices); }
  AnimFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimFrameBuilder &operator=(const AnimFrameBuilder &);
  flatbuffers::Offset<AnimFrame> Finish() {
    auto o = flatbuffers::Offset<AnimFrame>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimFrame> CreateAnimFrame(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> meshMatrices = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> boneMatrices = 0) {
  AnimFrameBuilder builder_(_fbb);
  builder_.add_boneMatrices(boneMatrices);
  builder_.add_meshMatrices(meshMatrices);
  return builder_.Finish();
}

struct Anim FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESHES = 4,
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimFrame>> *meshes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimFrame>> *>(VT_MESHES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESHES) &&
           verifier.Verify(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           verifier.EndTable();
  }
};

struct AnimBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimFrame>>> meshes) { fbb_.AddOffset(Anim::VT_MESHES, meshes); }
  AnimBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimBuilder &operator=(const AnimBuilder &);
  flatbuffers::Offset<Anim> Finish() {
    auto o = flatbuffers::Offset<Anim>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Anim> CreateAnim(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimFrame>>> meshes = 0) {
  AnimBuilder builder_(_fbb);
  builder_.add_meshes(meshes);
  return builder_.Finish();
}

struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERTICES = 4,
    VT_NORMALS = 6,
    VT_INDICES = 8,
    VT_COLORS = 10,
    VT_UVS = 12,
    VT_TEXTURE = 14,
    VT_BONEINDICES = 16,
    VT_BONEWEIGHTS = 18,
  };
  const flatbuffers::Vector<float> *vertices() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_VERTICES); }
  const flatbuffers::Vector<float> *normals() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_NORMALS); }
  const flatbuffers::Vector<int32_t> *indices() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INDICES); }
  const flatbuffers::Vector<float> *colors() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_COLORS); }
  const flatbuffers::Vector<float> *uvs() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_UVS); }
  const flatbuffers::String *texture() const { return GetPointer<const flatbuffers::String *>(VT_TEXTURE); }
  const flatbuffers::Vector<int32_t> *boneIndices() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BONEINDICES); }
  const flatbuffers::Vector<float> *boneWeights() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_BONEWEIGHTS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VERTICES) &&
           verifier.Verify(vertices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NORMALS) &&
           verifier.Verify(normals()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INDICES) &&
           verifier.Verify(indices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COLORS) &&
           verifier.Verify(colors()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UVS) &&
           verifier.Verify(uvs()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXTURE) &&
           verifier.Verify(texture()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BONEINDICES) &&
           verifier.Verify(boneIndices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BONEWEIGHTS) &&
           verifier.Verify(boneWeights()) &&
           verifier.EndTable();
  }
};

struct MeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<float>> vertices) { fbb_.AddOffset(Mesh::VT_VERTICES, vertices); }
  void add_normals(flatbuffers::Offset<flatbuffers::Vector<float>> normals) { fbb_.AddOffset(Mesh::VT_NORMALS, normals); }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> indices) { fbb_.AddOffset(Mesh::VT_INDICES, indices); }
  void add_colors(flatbuffers::Offset<flatbuffers::Vector<float>> colors) { fbb_.AddOffset(Mesh::VT_COLORS, colors); }
  void add_uvs(flatbuffers::Offset<flatbuffers::Vector<float>> uvs) { fbb_.AddOffset(Mesh::VT_UVS, uvs); }
  void add_texture(flatbuffers::Offset<flatbuffers::String> texture) { fbb_.AddOffset(Mesh::VT_TEXTURE, texture); }
  void add_boneIndices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> boneIndices) { fbb_.AddOffset(Mesh::VT_BONEINDICES, boneIndices); }
  void add_boneWeights(flatbuffers::Offset<flatbuffers::Vector<float>> boneWeights) { fbb_.AddOffset(Mesh::VT_BONEWEIGHTS, boneWeights); }
  MeshBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MeshBuilder &operator=(const MeshBuilder &);
  flatbuffers::Offset<Mesh> Finish() {
    auto o = flatbuffers::Offset<Mesh>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<Mesh> CreateMesh(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<float>> vertices = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> normals = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> indices = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> colors = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> uvs = 0,
   flatbuffers::Offset<flatbuffers::String> texture = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> boneIndices = 0,
   flatbuffers::Offset<flatbuffers::Vector<float>> boneWeights = 0) {
  MeshBuilder builder_(_fbb);
  builder_.add_boneWeights(boneWeights);
  builder_.add_boneIndices(boneIndices);
  builder_.add_texture(texture);
  builder_.add_uvs(uvs);
  builder_.add_colors(colors);
  builder_.add_indices(indices);
  builder_.add_normals(normals);
  builder_.add_vertices(vertices);
  return builder_.Finish();
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESHES = 4,
    VT_ANIMES = 6,
  };
  const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *meshes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *>(VT_MESHES); }
  const flatbuffers::Vector<flatbuffers::Offset<Anim>> *animes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Anim>> *>(VT_ANIMES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESHES) &&
           verifier.Verify(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANIMES) &&
           verifier.Verify(animes()) &&
           verifier.VerifyVectorOfTables(animes()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes) { fbb_.AddOffset(Scene::VT_MESHES, meshes); }
  void add_animes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Anim>>> animes) { fbb_.AddOffset(Scene::VT_ANIMES, animes); }
  SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    auto o = flatbuffers::Offset<Scene>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Anim>>> animes = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_animes(animes);
  builder_.add_meshes(meshes);
  return builder_.Finish();
}

inline const rechor::model::Scene *GetScene(const void *buf) { return flatbuffers::GetRoot<rechor::model::Scene>(buf); }

inline bool VerifySceneBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<rechor::model::Scene>(); }

inline void FinishSceneBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<rechor::model::Scene> root) { fbb.Finish(root); }

}  // namespace model
}  // namespace rechor

#endif  // FLATBUFFERS_GENERATED_SCENE_RECHOR_MODEL_H_
